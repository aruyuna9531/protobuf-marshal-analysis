# 程序输出结果

8 90 16 166 255 255 255 255 255 255 255 255 1 24 50 32 244 3 40 59 48 60 61 60
0 0 0 73 51 51 51 51 51 51 15 64 85 102 102 134 64 88 1 96 1 106 2 8 18 114 4 8
1 16 1 114 4 8 2 16 2 122 3 1 0 1 130 1 6 102 106 97 107 102 106 138 1 6 106 106
105 101 106 102 149 1 90 0 0 0 153 1 100 0 0 0 0 0 0 0

拆成二进制

↓field1（4~7位），最后3位wt=0

00001/000 | 01011010 ←value = 90

8 | 90

↓field2     ↓最高位一直到0为止，从后往前拼（即小端序），一共57个1加0100110，1011010的补码，即-90

00010/000 | 1/0100110 1/1111111 1/1111111 1/1111111 1/1111111 1/1111111 1/1111111 1/1111111 1/1111111 0/0000001

16 | 166 255 255 255 255 255 255 255 255 1

↓field3     ↓ 50

00011/000 | 00110010

24 | 50

↓field4     ↓ 1 1111 0100，即500

00100/000 | 1/1110100 0/0000011

32 | 244 3

↓5          ↓zigzag32，-30，正数原码11110，反码11100001，补码11100010，左移一位11000100，符号位放最后11000101，然后除最后一位全部取反00111011

00101/000 | 00111011

40 | 59 

↓6          ↓zigzag64，30，正数直接左移1位结束，轻松

00110/000 | 00111100

48 | 60

↓7，wt=5    ↓ wt=5时，无论多小的数字，一定要占4个字节。此时和varint规则不一样，所有的8位都是值的一部分，顺序仍然是靠前的byte是低位。

00111/101 | 00111100 00000000 00000000 00000000

61 | 60 0 0 0

field8的值是0，marshal的时候直接忽略0值

↓9，wt=1    ↓ 64位定长浮点型

01001/001 | 00110011 00110011 00110011 00110011 00110011 00110011 00001111 01000000

73 | 51 51 51 51 51 51 15 64

↓10，wt=5   ↓ 32位定长浮点型

01010/101 | 01100110 01100110 10000110 01000000

85 | 102 102 134 64

↓11          ↓ 布尔型，true是1

01011/000  | 00000001

88 | 1

↓12         ↓ 枚举值1

01100/000 | 00000001

96 | 1

↓13，wt=2   ↓这里wt=2要显式表示后面几个字节属于本数据（包括所有field和value字段），如果这个数超过8位同varint处理

01101/010 | 00000010 || 00001/000 | 00010010  ←最后几个字节是嵌套类型数据本体，格式也是field+value，按通常情况展开

106 | 2 || 8 | 18

↓14，wt=2                ↓1 表示key    ↓key的值    ↓2 表示value  ↓value的值。key，value各自遵循field-value格式。

01110/010 | 00000100 || (00001/000 | 00000001 || 00010/000 | 00000001 )

114 | 4 || (8 | 1 || 16 | 1)

↓14 这里map有2组键值对，这里重复利用了field表示属于同一个map。其他同上。

01110/010 | 00000100 || (00001/000 | 00000010 || 00010/000 | 00000010 )

114 | 4 || (8 | 2 || 16 | 2)

↓15                      ↓数组里的3个值

01111/010 | 00000011 || 00000001 00000000 00000001 

122 | 3 || 1 0 1

↓16 这里field超过了4位，第一个field字节最高位置1，表示后面一字节也是field的一部分，将后面一字节的7位和自己的4位拼起来才是field id（16）。wt仍然是第一个byte的后3位。

↓ 这也是为什么protobuf建议1-15的id留给常用数据。      ↓字符串的内容

1/0000/010 0/0000001 | 00000110 || 01100110 01101010 01100001 01101011 01100110 01101010 

130 1 | 6 || 102 106 97 107 102 106

↓17 []byte其实跟数组类似。

1/0001/010 0/0000001 | 00000110 || 01101010 01101010 01101001 01100101 01101010 01100110 

138 1 | 6 || 106 106 105 101 106 102

↓18                    ↓32位定长整型

1/0010/101 0/0000001 | 01011010 00000000 00000000 00000000

149 1 | 90 0 0 0

↓19                    ↓64位定长整型

1/0011/001 0/0000001 | 01100100 00000000 00000000 00000000 00000000 00000000 00000000 00000000

153 1 | 100 0 0 0 0 0 0 0

-----------

每个数据由一个field和一个value组成

field，从第1个byte开始，后3位代表wire type(wt)，往前4位是id（的一部分，如果id太大）

最高1位代表这个数据是否到此为止，如果是1，代表后面那个byte还是这个数据的一部分，该byte后面7位接在自己的前面，如果后面的byte最高位仍是1，继续如此往后接直到最高位是0为止

然后紧接着就是value，根据wt，站的位数不一样。

Wire Type | 解释 | 数据类型

0 | 变长型（见下文） | int32, int64, uint32, uint64, sint32, sint64, bool, enum

1 | 固定8字节 | fixed64, sfixed64, double

2 | 需显式告知长度（见下文） | string, bytes, 嵌套类型（embedded messages），repeated字段

5 | 固定4字节 | fixed32, sfixed32, float

1类型的最高位和field一样，1表示后面那个byte仍然是本数据的一部分，直到是0为止，每个byte的后7位按小端序组合成数据。

1和5类型就是固定长度，值多大多小，后面的4/8字节一定属于本数据。

2类型就是后面需要一个值（varint格式）表示接下来多少byte是本数据内容，然后是数据。

————————

一些额外验证：

```go
&test.Msg{
    Fsint32: 600,
}
```

输出：

00101000 10110000 00001001

第1字节是索引位，略

600的二进制是10 0101 1000，所以zigzag32/zigzag64超过7位时依然按照最高位置1表示后一字节属于本数据一部分的方式排布。

```protobuf
repeated int32 intarray = 20; // 数组
```
```go
&test.Msg{
    Intarray: []int32{655, 300, 108, 910, 245},
}
```

输出：

10100010 00000001 00001001 10001111 00000101 10101100 00000010 01101100 10001110 00000111
11110101 00000001

前两字节 10100010 00000001 表示第20个field，略。

第三字节 00001001 接下来数据占用9字节。

四-五字节 10001111 00000101 按varint规则，得到655

六-七字节 10101100 00000010 得到300

八-九字节 01101100 得到108

十-十一字节 10001110 00000111 得到910

十二-十三字节 11110101 00000001 得到245

因此数组内元素排布严格按照该数组的数据类型在protobuf的排布方式，无间隔地插入字节。

```go
&test.Msg{
    Fmap: map[uint32]int32{1: 1, 2: 2, 3: 3},
}
```

可能的输出：

01110010 00000100 00001000 00000011 00010000 00000011 01110010 00000100 00001000 00000001
00010000 00000001 01110010 00000100 00001000 00000010 00010000 00000010

go的map在内存里是无序的，序列化的结果也是无序的，上述序列化的顺序是3，1，2。